[{"content":"\n\n# 赋值\n一般情况下的赋值都是地址引用的传递(引用和指针是有区别的，在java里面没有指针，只有引用，引用是不能被修改的；而指针是可以修改的，如在C++里面有pointer++)\n\n所以在使用JAVA的时候，对于赋值对象的修改需要小心。比如在某些框架下的依赖注入，对于注入的对象，在使用过程中，如果进行修改可能会得到不同的结果。\n\n```JAVA\npublic class Test {\n\t\n\tpublic String name;\n\n\tpublic static void main(String[] args) {\n\t\t//定义变量test，并将其名字定义为dog\n\t\tTest test = new Test();\n\t\ttest.name = \"dog\";\n\t\t\n\t\t//将test赋值给test2，修改其名字为cat\n\t\tTest test2 = test;\n\t\ttest2.name = \"cat\";\n\t\t\n\t\tSystem.out.println(test.name);\n\t\tSystem.out.println(test2.name);\n\t}\n\n}\n```\n\n其输出结果为\n```out\ncat\ncat\n```\n\n可以看出test和test1引用的是内存中的同一个对象，修改任何一个引用，都会影响其他引用。\n\n# 浅拷贝\n浅拷贝是指拷贝对象本身（包括对象中的基本变量），不拷贝对象中的引用。在JAVA中，实现浅拷贝的方法是实现Cloneable接口\n\n举个例子\n```JAVA\npublic class Test implements Cloneable {\n\t\n\tpublic String name;\n\tpublic List\u003cString\u003e values = new ArrayList\u003cString\u003e();\n\t\n\tpublic Test clone() {\n\t\tTest testCloned = null;\n        try {\n        \ttestCloned = (Test) super.clone();\n        } catch (CloneNotSupportedException e) {\n            System.out.println(e.toString());\n        }\n \n        return testCloned;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t//定义变量test\n\t\tTest test = new Test();\n\t\ttest.name = \"dog\";\n\t\ttest.values.add(0, \"dog value\");\n\t\t\n\t\t//将test克隆给test2，并修改test2的内容\n\t\tTest test2 = test.clone();\n\t\ttest2.name = \"cat\";\n\t\ttest2.values.set(0, \"cat value\");\n\t\t\n\t\tSystem.out.println(test.name + \":\" + test.values.get(0));\n\t\tSystem.out.println(test2.name + \":\" + test2.values.get(0));\n\t\t\n\t}\n\t\n}\n```\n\n其结果为\n```out\ndog:cat value\ncat:cat value\n```\n\n可以看出在浅拷贝中，修改基本变量name被拷贝了，所以修改name不会影响其他对象；而List属性则没有被拷贝，所有对象的List属性的值都改变了\n\n# 深拷贝\n## 1. 伪深拷贝\n有一种假的深拷贝，它的方法是对所有涉及到的非基本类型变量都实现Cloneable接口。\n\n比如上面的例子，做法就是重写List对象，让它也实现Cloneable接口，并且修改Test实现的clone的函数。\n```JAVA\ntestCloned = (Test) super.clone();\ntestCloned.values = (List) values.clone();\n```\n为什么说是伪克隆呢？因为如果List对象里面也有非基本类型变量，那么这些非基本变量类型不会被克隆。\n\n比如：假设重写的List里面有对象AClass，用上面的方法，AClass是不会被拷贝的。\n\n这种伪深拷贝的关键是`覆盖拷贝`。\n\n![](/blog/images/copy/copy.png)\n\n## 2. 深拷贝\n序列化(串行化)是深拷贝的一个方法。\n\n过程：内存对象 -\u003e 序列化 -\u003e 新的内存对象。 这样前后两个对象的内容是一致的，但是在内存中的引用不一样。\n\n序列化的过程如下：\n\n```JAVA\npublic static \u003cT extends Serializable\u003e T clone(T obj) {\n\tT clonedObj = null;\n\ttry {\n\t\t//将对象变成序列（序列号）\n\t\tByteArrayOutputStream output = new ByteArrayOutputStream();\n\t\tObjectOutputStream objOutput = new ObjectOutputStream(output);\n\t\tobjOutput.writeObject(obj);\n\t\tobjOutput.close();\n\t\t\n\t\t//将序列还原成对象（反序列化）\n\t\tByteArrayInputStream input = new ByteArrayInputStream(output.toByteArray());\n\t\tObjectInputStream objInput = new ObjectInputStream(input);\n\t\t\t\n\t\tclonedObj = (T) objInput.readObject();\n\t\t\n\t\tobjInput.close();\n\t} catch (IOException | ClassNotFoundException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\n\t\t\n\treturn clonedObj;\n\t\t\n}\n```\n\n在使用这个clone函数的时候，需要让原有对象实现Serializable接口(从clone函数的参数也能看出)。\n\n```JAVA\npublic class Test implements Serializable {\n\n\tprivate static final long serialVersionUID = -2386382139170837795L;\n\tpublic String name;\n\tpublic List\u003cString\u003e values = new ArrayList\u003cString\u003e();\n\n\tpublic static void main(String[] args) {\n\t\t//定义变量test\n\t\tTest test = new Test();\n\t\ttest.name = \"dog\";\n\t\ttest.values.add(0, \"dog value\");\n\t\t\n\t\t//将test克隆给test2\n\t\tTest test2 = clone(test);\n\t\ttest2.name = \"cat\";\n\t\ttest2.values.set(0, \"cat value\");\n\t\t\n\t\tSystem.out.println(test.name + \":\" + test.values.get(0));\n\t\tSystem.out.println(test2.name + \":\" + test2.values.get(0));\n\t\t\n\t}\n\t\n}\n```\n结果为:\n```out\ndog:dog value\ncat:cat value\n```\n\n\n\n\n\n\n\n","cover":"","link":"copy.html","preview":"\u003cp\u003eJAVA里面变量有两种拷贝的方法，深拷贝和浅拷贝。\u003c/p\u003e\n","title":"JAVA深拷贝和浅拷贝"},{"content":"\n\n## 题目\n最近学长们在各种投简历，他们在线笔试的时候正好看到一道很有趣的在线笔试题，就自己做了一下，由于没有答案，所以也不知道对不对。\n\n- 1. 对于一个长度为N的整形数组A，数组里所有的数都是正整数，对于两个满足`0\u003c=X\u003c=Y\u003cN`的整数，A[X],A[X+1]...A[Y]构成A的一个切片，记作`(X,Y)`。\n- 2. 用三个下标m1,m2,m3满足条件 `0\u003cm1`, `m1+1\u003cm2`, `m2+1\u003cm3\u003cN-1`。\n- 3. 可以把这个整数分成 `(0,m1-1)`, `(m1+1,m2-1)`, `(m2+1,m3-1)`, `(m3+1,N-1)` 四个切片。如果这四个切片中的整数求和相等，称作“四等分”。\n- 4. 编写一个函数，判断是否可以四等分，如果可以，返回true，否则返回false。\n- 5. 限制条件: N \u003c= 1000000，整数范围取值介于 0 到 1000000之间。\n- 6. 要求: 时间复杂度O(N)，额外的存储空间最多为O(N);\n- 7. 对于数组 A=[2,5,1,1,1,1,4,1,7,3,7]，存在下标2，7，9使得A分成四个切片 [2,5] , [1,1,1,4], [7], [7] 这四个切片求和相等。 对于数组 A=[10,2,11,13,1,1,1,1,1]找不到四等分，所以返回false。\n\n## 方法\n首先，由于约束条件`0\u003cm1`, `m1+1\u003cm2`, `m2+1\u003cm3\u003cN-1`，可知最小值 m1=1, m2=3, m3=5, N\u003e6， 所以对于数组长度小于等于6的返回false。\n\n\u003col\u003e\n\t\u003cli\u003e任取满足条件的m1,m2,m3构成四个切片，并且求四个切片的和 sum1, sum2, sum3, sum4\u003c/li\u003e\n\t\u003cimg src=\"images/interview-questions/1.png\"\u003e\n\t\u003cli\u003e如果 \u003cspan style=\"color:red;\"\u003esum1=sum2=sum3=sum4\u003c/span\u003e ,那么说明可以是一个四等分的切片，且 \u003cspan style=\"color:red;\"\u003em1,m2,m3\u003c/span\u003e 就是结果，跳出迭代\u003c/li\u003e\n\t\u003cli\u003e如果某次迭代不满足这个条件，我的想法是 \u003cspan style=\"color:red;\"\u003e消灭最大的sum\u003c/span\u003e，也就是将\u003cspan style=\"color:red;\"\u003e和最大\u003c/span\u003e的切片的边缘分配给相邻较小的切片。(切片是相邻的，所以只能分配给相邻的另一个切片)\n\t\t\u003cul\u003e\n\t\t\t\u003cli\u003e当sum1最大的时候，将m1往左边移1位(\u003cspan style=\"color:red;\"\u003em1=m1-1\u003c/span\u003e)，此时 \u003cspan style=\"color:red;\"\u003esum1 = sum1 - A[m1-1]\u003c/span\u003e,而 \u003cspan style=\"color:red;\"\u003esum2 = sum2 + A[m1]\u003c/span\u003e。\u003c/li\u003e\n\t\t\t\u003cli\u003e当sum2最大的时候，切片2的边缘分配给相邻较小的切片。也就是说，当 \u003cspan style=\"color:red;\"\u003esum1 \u003e sum3\u003c/span\u003e 的时候，分配给sum3,此时 \u003cspan style=\"color:red;\"\u003em2=m2-1\u003c/span\u003e, \u003cspan style=\"color:red;\"\u003esum2 = sum2 - A[m2-1]\u003c/span\u003e,\u003cspan style=\"color:red;\"\u003e sum3 = sum3 + A[m2]\u003c/span\u003e;同理当 \u003cspan style=\"color:red;\"\u003esum1 \u003c= sum3\u003c/span\u003e 的时候，分配给sum1,方法如上\u003c/li\u003e\n\t\t\t\u003cli\u003e当sum3最大的时候，这种情况和sum2最大类似(都是数组的内部切片)\u003c/li\u003e\n\t\t\t\u003cli\u003e当sum4最大的时候，这种情况和sum1最大类似(都是数组的外部切片)\u003c/li\u003e\n\t\t\u003c/ul\u003e\n\t\u003c/li\u003e\n\t\u003cli\u003e重复步骤2，3\u003c/li\u003e\n\t\u003cli\u003e失败跳出的条件：最大切片的位置变化进入循环。如\u003cspan style=\"color:red;\"\u003e1 -\u003e 2 -\u003e 1\u003c/span\u003e, 其意义是：当切片1和最大的时候，分配边缘给切片2；当切片2和最大的时候，又将边缘还给了切片1，如此进入死循环。\u003c/li\u003e\n\u003c/ol\u003e\n\n## 分析\n### 空间复杂度\n除了几个可数的变量以外，没有使用额外的空间，所以空间复杂度为 O(N)\n\n### 时间复杂度\n求sum1-sum4的时候，需要遍历一遍数组，时间花费N\n\n步骤3，其实是在调整m1,m2,m3的位置，它的位置变化最多为N，因为 0\u003cm1\u003cm2\u003cm3\u003cN，而m1,m2,m3只会往一个方向变化，否则就会进入失败的条件。所以时间复杂度为 O(N)\n\n## 注意\n这个方法不一定对，只是我的一个想法\n\n## 代码\n``` java\npackage main;\n\n\npublic class Main {\n\n\tpublic static boolean handle(int[] A) {\n\t\tboolean flag = false;\n\n\t\tint m1 = 1, m2 = 3, m3 = 5; \n\t\t//用数组存比较好，这里为了清楚展示就没用数组\n\n\t\tlong sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0; \n\t\t//用数组存比较好，这里为了清楚展示就没用数组\n\n\t\tint latestMax1 = -3, latestMax2 = -2, thisMax = -1; \n\t\t//用数组存比较好，这里为了清楚展示就没用数组\n\t\t//latestMax1 上上次取的最大值所在的位置\n\t\t//latestMax2 上次取的最大值所在的位置\n\t\t//thisMax 当前的最大值所在的位置\n\t\t\n\t\tif (A.length \u003c= 6) {\n\t\t\treturn flag;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i \u003c A.length; i++) {\n\t\t\tif (i \u003e= 0 \u0026\u0026 i \u003c m1) { //求sum1\n\t\t\t\tsum1 += A[i];\n\t\t\t}\n\t\t\tif (i \u003e m1 \u0026\u0026 i\u003c m2) { //求sum2\n\t\t\t\tsum2 += A[i];\n\t\t\t}\n\t\t\tif (i \u003e m2 \u0026\u0026 i \u003c m3) { //求sum3\n\t\t\t\tsum3 += A[i];\n\t\t\t}\n\t\t\tif (i \u003e m3) { //求sum4\n\t\t\t\tsum4 += A[i];\n\t\t\t}\n\t\t}\n\t\t//以上时间花费 N\n\t\t\n\t\t\n\t\twhile(true) {\n\t\t\tif (sum1 == sum2 \u0026\u0026 sum1 == sum3 \u0026\u0026 sum1 == sum4) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (latestMax1 !=latestMax2 \u0026\u0026 latestMax1 == thisMax) {\n\t\t\t\t//判断失败\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tlatestMax1 = latestMax2;\n\t\t\tlatestMax2 = thisMax;\n\t\t\t\n\t\t\tif (sum1 \u003e= sum2 \u0026\u0026 sum1 \u003e= sum3 \u0026\u0026 sum1 \u003e= sum4) { \n\t\t\t\t//sum1 最大\n\t\t\t\tsum1 -= A[m1-1];\n\t\t\t\tsum2 += A[m1];\n\t\t\t\tm1 -= 1; // m1 往左移1位\n\t\t\t\tthisMax = 1;\n\t\t\t} else if (sum2 \u003e= sum1 \u0026\u0026 sum2 \u003e= sum3 \u0026\u0026 sum2 \u003e= sum4) { \n\t\t\t\t//sum2 最大\n\t\t\t\tif (sum1 \u003e sum3) { //sum1比sum3大的情况\n\t\t\t\t\tsum2 -= A[m2-1];\n\t\t\t\t\tsum3 += A[m2];\n\t\t\t\t\tm2 -= 1;\n\t\t\t\t} else {\n\t\t\t\t\tsum1 += A[m1];\n\t\t\t\t\tsum2 -= A[m1+1];\n\t\t\t\t\tm1 += 1;\n\t\t\t\t}\n\t\t\t\tthisMax = 2;\n\t\t\t} else if (sum3 \u003e= sum1 \u0026\u0026 sum3 \u003e= sum2 \u0026\u0026 sum3 \u003e= sum4) { \n\t\t\t\t//sum3 最大\n\t\t\t\tif (sum2 \u003e sum4) { //sum2比sum4大的情况\n\t\t\t\t\tsum4 += A[m3];\n\t\t\t\t\tsum3 -= A[m3-1];\n\t\t\t\t\tm3 -= 1;\n\t\t\t\t} else {\n\t\t\t\t\tsum2 += A[m2];\n\t\t\t\t\tsum3 -= A[m2+1];\n\t\t\t\t\tm2 += 1;\n\t\t\t\t}\n\t\t\t\tthisMax = 3;\n\t\t\t} else if (sum4 \u003e= sum1 \u0026\u0026 sum4 \u003e= sum2 \u0026\u0026 sum4 \u003e= sum3) { \n\t\t\t\t//sum4 最大\n\t\t\t\tsum4 -= A[m3+1];\n\t\t\t\tsum3 += A[m3];\n\t\t\t\tm3 += 1;\n\t\t\t\tthisMax = 4;\n\t\t\t} \n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.print(flag);\n\t\tif (flag) {\n\t\t\tSystem.out.println(\",m1=\" + m1 + \",m2=\" + m2 + \",m3=\" + m3);\n\t\t}\n\t\t\n\n\t\treturn flag;\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\tint A[] = {2,5,1,1,1,1,4,1,7,3,7};\n\t\tint B[] = {10,2,11,13,1,1,1,1,1};\n\t\thandle(A);\n\t\thandle(B);\n\t}\n\n}\n\n```\n\n输出：\n``` sysout\ntrue,m1=2,m2=7,m3=9\nfalse\n```\n\n如我在代码中的注释，用数组去存定义的变量更好，以position去进行if判断，可以减少重复代码，但是我想让代码容易被看懂，所以没用数组，而是枚举if\n\n","cover":"","link":"interview-questions.html","preview":"\u003cp\u003e最近学长们在各种投简历，他们在线笔试的时候正好看到一道很有趣的在线笔试题，就自己做了一下，由于没有答案，所以也不知道对不对。\u003c/p\u003e\n","title":"某里JAVA实习在线笔试题"},{"content":"\n\n## date，timestamp和datetime\n首先，介绍一下mysql中，常用的时间字段，有date、timestamp和datetime。\n\n- `date` 大小：3 bytes，格式：'YYYY-MM-DD'，范围：'1000-01-01 ~ 9999-12-31'\n- `timestamp` 大小：4 bytes，格式：'YYYY-MM-DD HH:MM:SS'，范围：'1970-01-01 08:00:01 ~ 2038-01-19 11:14:07'\n- `datetime` 大小：8 bytes，格式：'YYYY-MM-DD HH:MM:SS'，范围：'1000-01-01 00:00:00 ~ 9999-12-31 23:59:59'\n\n在需要精确到时秒分的情况下，我们通常会选择timestamp或者datetime。当时我看别人写的都是用timestamp，而自己又没有去查mysql的文档，所以用的时间戳都是timestamp。\n\n## 问题描述\n首先，我们创建一张有timestamp类型的表，用于记录名字和注册时间\n``` mysql\ncreate table test1 (\nid serial primary key,\nname varchar(30) not null,\nregister_time timestamp not null\n);\n```\n然后插入一条数据\n``` myysql\ninsert into test1(name,register_time) values('dog',now());\n```\n![](/blog/images/mysql-timestamp/selectdata.png)\n到目前为止，还没有出现任何问题\n\n有一天，dog用户表示自己改名字了，他觉得自己应该叫'chick'，然后他就改名字了\n``` mysql\nupdate test1 set name = 'chick' where id = 1;\n```\n![](/blog/images/mysql-timestamp/selectdata2.png)\n好像也没什么问题。等等！注册时间怎么变了？dog表示不服，因为老用户有很多福利，而自己不过是修改了一下名字，怎么注册时间更新了？\n\n## timestamp\ntimestamp所占存储空间比较小，但是它有一个特性：默认情况下，在`insert, update`数据时，timestamp 列会自动以当前时间`填充/更新`。\n\n基于这个特性，timestamp适用类似于`updated_time`的字段，而且它所占的存储空间也比较小；不过需要注意的是timestamp比较受时区timezone的影响。\n\n当然也可以取消timestamp在`update`下的自动更新时间\n``` mysql\ncreate table test2 (\nid serial primary key,\nname varchar(30) not null,\nregister_time timestamp not null default current_timestamp\n);\n```\n这种情况下，当执行`update`的时候，不会去自动更新时间\n\n## datetime\n它只是个普通的时间字段，不会自动以当前时间`填充/更新`，注意的是datetime在非空的情况下也会自动填充。\n``` mysql \ncreate table test3 (\nid serial primary key,\nname varchar(30) not null,\nregister_time datetime not null\n);\ninsert into test3(name) values('dog');\n```\n上述情况不会报错，而是会给出一个warning，而且datetime字段会自动填充。\n![](/blog/images/mysql-timestamp/selectdata3.png)\n\n当然如果是可为空的情况下，那么register_time的值就是NULL。\n\n由于datetime比较大，选择datetime作为索引，可能会遇到大量数据查询慢的情况，不过可以使用分区表解决。","cover":"","link":"mysql-timestamp.html","preview":"\u003cp\u003e在实习的时候，看到mysql建表，对于时间字段用的都是timestamp类型。之后在自己的项目中，不问缘由，也全部使用timestamp，然后发生了一系列问题。\u003c/p\u003e\n","title":"mysql timestamp和datetime"},{"content":"\n\n## web页面乱码\n如果是html页面，可以使用\n``` html\n\u003cmeta http-equiv=\"content-type\" content=\"text/html;charset=gbk\" /\u003e\n```\n如果是jsp页面，可以使用\n``` html\n\u003c%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%\u003e  \n```\n\n## 后端服务器中中文乱码\n当服务器接收到网页请求参数，参数是中文，而且发生乱码，则可能是由于一下原因：\n\n- web页面中文编码和后端服务器编码不一致，比如说web客户端使用的是ISO的编码，而服务器使用的是其他编码，就会出现乱码\n- 客户端使用了URLEncode\n\n可能的解决方案：\n\n- 对于第一种原因，需要对接收的每个字符串变量重新编码或者对请求增加filter\n\n\u0026emsp;\u0026emsp;\u0026emsp;1. 重新编码比较简单\n\n``` java\nnew String(request.getParameter(\"str\").getBytes(\"ISO-8859-1\"),\"UTF-8\")\n```\n\n\u0026emsp;\u0026emsp;\u0026emsp;2. 增加filter\n\n\u0026emsp;\u0026emsp;\u0026emsp;修改项目配置文件`web.xml`，增加如下代码\n``` xml\n\u003cfilter\u003e  \n    \u003cfilter-name\u003echaracterEncodingFilter\u003c/filter-name\u003e  \n    \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e  \n    \u003cinit-param\u003e  \n    \t\u003cparam-name\u003eencoding\u003c/param-name\u003e  \n    \t\u003cparam-value\u003eUTF-8\u003c/param-value\u003e  \n    \u003c/init-param\u003e  \n    \u003cinit-param\u003e  \n            \u003cparam-name\u003eforceEncoding\u003c/param-name\u003e  \n            \u003cparam-value\u003etrue\u003c/param-value\u003e  \n    \u003c/init-param\u003e  \n\u003c/filter\u003e  \n\u003cfilter-mapping\u003e  \n    \u003cfilter-name\u003echaracterEncodingFilter\u003c/filter-name\u003e  \n    \u003curl-pattern\u003e/*\u003c/url-pattern\u003e  \n\u003c/filter-mapping\u003e  \n```\n\u003cbr/\u003e\n\n- 对于第二种原因，一般是不会发生乱码的，发生乱码一般是由于请求为`GET`请求，中文参数放在URL内，而服务器没有进行相应的设置\n\n\u0026emsp;\u0026emsp;\u0026emsp;以tomcat为例，修改`server.xml`，增加`URIEncoding=\"UTF-8\"`即可\n``` xml\n\u003cConnector URIEncoding=\"UTF-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/\u003e\n```\n\n## 数据库乱码（mysql）\n如果服务没有出现乱码，那么说明是数据库的语言配置出问题了，可以通过`show variables like 'character_set_%';`来查看数据库的编码\n![](/blog/images/springMVC-mysql-gibberish/mysql-charset.jpeg)\n\n其中需要关注的是`服务器`、`数据库`和`数据表部分`的编码，如果这三部分不是你想要的编码，那么需要修改。\n``` sql\nmysql\u003e SET character_set_client='utf8';\nmysql\u003e SET character_set_connection='utf8';\nmysql\u003e SET character_set_results='utf8';\n```\n\n\u003e 注意的是，上述的仅作用于当前的session，也就是当前数据库用户退出后失效\n\n如果想永久设置，需要修改mysql的`my.cnf`，通过`vim /etc/my.cnf`命令来编辑该文件，进入编辑状态后，在其中修改\n``` cnf\n[mysqld]\ndefault-character-set=utf8\n\n[client]\ndefault-character-set=utf8\n\n[mysql]\ndefault-character-set=utf8\n```\n修改完成后，重启数据库即可，`service mysqld restart`\n\n除了上述修改编码的方式，还可以在建表时指定表的charset。有的时候一个数据库可能有多个用户在使用，如果直接修改整个数据库的编码，可能造成其他用户的不便，所以可以不改变整个系统的语言，仅指定自己所建表的编码\n``` sql\ncreate table mytable(\n\tname varchar(100)\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\n\n\n","cover":"","link":"springmvc-mysql-gibberish.html","preview":"\u003cp\u003e在使用springMVC + Hibernate时，有时会出现中文乱码。一般中文乱码出现在web页面，后端服务器和数据库中，而其原因有很多。\u003c/p\u003e\n","title":"springMVC-mysql中文乱码"},{"content":"\n\n## github个人主页(github pages)简介\n\ngithub pages简介以及如何搭建在[github help](https://help.github.com/categories/github-pages-basics/)里有详细的描述。\n本文目的是将其步骤简化，达到快速搭建github个人主页的目的。\n\n### 搭建步骤\n1. 申请一个github账号\n2. 登录后，新建一个代码仓库，仓库名为 yourusername.github.io\n\n    ![新建代码仓库过程](/blog/images/github-personal-website/create_new_repository.jpeg)\n\n    \u003e 图片中的warning是由于本人已经创建过该仓库了\n\n3. 在本地电脑安装[github工具](https://git-for-windows.github.io/)，这里给出的是windows版本的，linux和mac的自行安装\n4. 在本地新建一个文件夹，进入文件夹后新建一个`index.html`的文件，用记事本打开它，在里面写入`我的个人主页`(如果你会html，那么可以在里面编辑自己想要的页面)\n5. 将该文件夹里面的文件`index.html`推到新建的代码仓库，github本地配置以及将代码推到远程仓库的教程已经有很多了，这里可以参照[这一篇](http://blog.csdn.net/qq_24489717/article/details/52556072)\n6. 上传代码完成后，可通过`yourusername.github.io`这个域名访问你的个人主页了\n","cover":"","link":"github-personal-website.html","preview":"\u003cp\u003egithub除了提供分布式代码管理，还提供了个人主页的搭建。\u003c/p\u003e\n","title":"github个人主页搭建"}]