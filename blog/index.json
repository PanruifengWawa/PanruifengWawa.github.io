[{"content":"\n\n## JNI\nJNI是Java Native Interface的简称，它可以调用其他语言编写的程序，主要是C和C++，具体的介绍网上有很多，就不再重复了\n\n我以前都是通过协议接口，HTTP、Socket等方式，实现Java调用其他程序的(松耦合、程序之间只关注接口格式)，所以从来没用过JNI\n\n## JNI Java部分代码\n```Java\nimport java.lang.reflect.Field;\npublic class Main {\n    \n    //declare native method\n    public native int add(int a, int b);\n\n    static {\n        try {\n            //set native c++ lib path\n            System.setProperty(\"java.library.path\", System.getProperty(\"java.library.path\") + \":/Users/dapan/Desktop/JniTest/jnilib\");\n            Field fieldSysPath = ClassLoader.class.getDeclaredField(\"sys_paths\");\n            fieldSysPath.setAccessible(true);\n            fieldSysPath.set(null, null);\n            \n            //set native c++ lib\n            System.loadLibrary(\"JNIADD\");\n        } catch(Exception e) {\n            //print Error\n            e.printStackTrace();\n        }\n        \n    }\n    public static void main(String[] args) {\n        \n        Main main = new Main();\n        int c = main.add(2, 3);\n        System.out.println(c);\n    }\n}\n```\n可以看出，我申明了一个native方法add，但是没有实现它。然后我设置了native C++库的路径，并且载入lib-\u003eJNIADD\n\n在主函数中，我调用的add函数\n\n之后，可以先编译函数`javac Main.java`，在编译时，我还没实现add函数\n\n# 生成JNI的头文件，并且实现\n执行`javah Main`后，会生成Main.h文件\n```\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include \u003cjni.h\u003e\n/* Header for class Main */\n\n#ifndef _Included_Main\n#define _Included_Main\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     Main\n * Method:    add\n * Signature: (II)I\n */\nJNIEXPORT jint JNICALL Java_Main_add\n  (JNIEnv *, jobject, jint, jint);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\n\n这个头文件就是Java调用C++的接口，所以需要实现这个头文件，因此我新建了一个Main.cpp的文件\n\n```\n#include \"Main.h\"\n\nJNIEXPORT jint JNICALL Java_Main_add\n  (JNIEnv *env, jobject obj, jint a, jint b) \n  {\n    return a + b ;\n  }\n```\n\n# 编译C++文件，并且打包成lib(mac版)\n- 编译cpp文件： `g++ -I $JAVA_HOME/include -c Main.cpp`，编译完成后会生成Main.o文件\n- 需要将Main.o打包成jnilib文件： `g++ -dynamiclib -o libJNIADD.jnilib Main.o` 打包的jnilib命名规范是libxxx.jnilib，其中xxx是我在Java中`System.loadLibrary(\"JNIADD\")`设置的library的名称\n- 最后将打包的jnilib放到Java中设置的`java.library.path`目录之一即可\n\n# 结果\n最后就可以用`java Main`运行java程序了\n\n以C++为例，在运行过程中，可以随时重新编写打包C++程序，使得程序变得很灵活；但是其可移植性会变差，因为对于不同的平台，需要重新编译C++文件。\n\n\n","cover":"","link":"java_jni.html","preview":"\u003cp\u003eJava JNI提供了Java调用C，C++的方式\u003c/p\u003e\n","title":"Java JNI"},{"content":"\n\n## 数据库引擎\n旧版本只有MyISAM支持全文索引，其他数据库引擎不支持（不过好像新的版本中，InnoDB也支持了）。所以在建表的时候需要指定MyISAM引擎\n```\ncreate table (\nid serial primary key,\nname text,\nname_fulltext text,\nfulltext(name_fulltext)\n)engine=MyISAM default charset=utf8;\n-- 网上有很多帖子贴出来的都是type=MyISAM，不知道是什么版本的语法，我的mysql版本是5.7.19，用的关键词是engine\n```\n\n## 指定全文索引\n如上面的建表语句所示，其中`fulltext(name_fulltext)`表示在`name_fulltext`列上创建全文索引。\n\n当然也可以在建表完成后，再创建全文索引。\n```\nCREATE FULLTEXT INDEX full_text_index_name ON myTable(name);\n-- 执行这句话的时候，对于InnoDB引擎的数据库表，会报一个warning，而MyISAM则不会。\n-- 0 row(s) affected, 1 warning(s): 124 InnoDB rebuilding table to add column FTS_DOC_ID Records: 0  Duplicates: 0  Warnings: 1\n```\n\n## 使用全文索引\n全文索引的基本单位是`词`\n\n使用方法如下\n```\nSELECT * FROM myTable WHERE MATCH(name_fulltext) AGAINST('赵信999999号');\n-- 当查询结果过多或过少的时候，上述语句可能会返回非预期结果，可以加 in boolean mode来避免这种情况\n\nSELECT * FROM myTable WHERE MATCH(name_fulltext) AGAINST('赵信999999号' in boolean mode);\n\nSELECT * FROM myTable WHERE MATCH(name_fulltext) AGAINST('+赵信999999号 -卡特1号' in boolean mode);\n-- 上述表示所查询的结果中必须包括词'赵信999999号'，但不包括'卡特1号'，注意是词\n\nSELECT * FROM myTable WHERE MATCH(name_fulltext) AGAINST('+赵信999999号 \u003e卡特1号 \u003c卡特2号' in boolean mode);\n-- \u003e和\u003c分别代表相关度高和低，上述语句表示所查询的结果中必须包括词'赵信999999号'，如果包含'卡特1号'，则排在前面，如果包含'卡特2号'，则排在后面\n-- 注意的是最终查询的顺序是：包含'赵信999999号'且'卡特1号' \u003e 包含'赵信999999号'且'卡特2号' \u003e 包含'赵信999999号'\n-- 也就是说，指定的\u003e和\u003c都会比没指定的排在前面\n\nSELECT * FROM myTable WHERE MATCH(name_fulltext) AGAINST('+赵信*' in boolean mode);\n-- *代表通配符，只能放在字符串后面，不能放在前面\n\nSELECT * FROM myTable WHERE MATCH(name_fulltext) AGAINST('+赵信999999号 +(\u003e卡特1号 \u003c卡特2号)' in boolean mode);\n-- 可以通过()来表示逻辑逻辑关系\n\nSELECT * FROM myTable WHERE MATCH(name_fulltext) AGAINST('+赵信999999号 ~卡特1号' in boolean mode);\n-- 可以通过~来降低相关度，但不会排除\n\nSELECT * FROM myTable WHERE MATCH(name_fulltext) AGAINST('\"赵信999999号 卡特1号\"' in boolean mode);\n-- 通过双引号，可以指定词组，但匹配到的一定是 ... 赵信999999号 卡特1号 ... 这个样子的\n\n-- 其实用法有很多，我这里写的用法是参考 http://blog.csdn.net/u011734144/article/details/52817766 这篇博文\n```\n\n## 与like对比\n### 性能\n性能其实很明显，一个全表扫描，一个索引扫描，索引扫描性能一定更高。\n\n举个例子，我在myTable表内插入了100万条数据，每一条数据具有相同内容的name和name_fulltext，但前者是无索引，而后者是有全文索引的。\n\n现在想从100万条数据中找出内容包含'赵信999999号'或'提莫500000号'(词)的行。语句如下\n```\nSELECT * from myTable WHERE name like '%赵信999999号%' or name like '%提莫500000号%';\nSELECT * FROM myTable WHERE MATCH(name_fulltext) AGAINST('赵信999999号 提莫500000号' in boolean mode);\n```\n\n![](/blog/images/mysql-full-text/a.jpg)\n\n可以看出，前者涉的rows为1000000，而后者为1，这就是表扫描和索引扫描的区别。\n\n时间消耗如下图\n\n![](/blog/images/mysql-full-text/b.jpg)\n\n### 功能\n个人觉得like的功能更强大点，like可以通过查找任意位置的字符串匹配。\n\n如`select * from myTable where name like '%赵信999999号%' or name like '%提莫500000号%';`，它可以查到任意位置包含这两个字符串的行，当然性能消耗大。\n\n而`SELECT * FROM myTable WHERE MATCH(name_fulltext) AGAINST('赵信999999号 提莫500000号' in boolean mode);`，它只能查到包含这两个词的row，也就是说，如果内容是 `赵信999999号单杀提莫500000号`这样的row，这个语句是查不到的，它只能查到`赵信999999号 单杀 提莫500000号`或者`赵信999999号,单杀,提莫500000号`类似的row。(全文索引的基本单位是`词`)。\n\n所以个人感觉全文索引对中文不太友好。英文的句子是由单词组成的，如`zhaoxin999999 kill timo500000`，很适合全文索引。而中文的句子，一般都是`赵信999999号单杀提莫500000号`，很少会是`赵信999999号 单杀 提莫500000号`(空格区别)。\n\n\n\n\n\n","cover":"","link":"mysql-full-text.html","preview":"\u003cp\u003emysql提供一种文本索引的方式，它的功能很像like，但是由于是通过索引检索的，所以速度很快\u003c/p\u003e\n","title":"mysql全文索引"},{"content":"\n\n## 主从复制\n主从复制是指有两个数据库，它们的角色分别是master和slave。所有数据库操作都在master端进行，slave会自动同步master的操作。\n\n## 主从复制目的\n- 最常见的目的就是备份\n- 用于数据挖掘。如果直接从生产数据库中挖掘，会占用数据库资源。\n- 数据库读写分离，减少负荷。master和slave同时投入生产，用户所有的写操作在master端进行，所有的读操作在slave端进行。将数据库访问请求分摊，降低负荷。\n\n## 环境准备\n我准备了两台服务器A和B，都是Ubuntu系统。记它们的ip分别是ipA和ipB。master对应A服务器，slave对应B服务器。\n\n## Master节点\n修改mysql的配置文件my.cnf，增加如下配置，然后重启mysql服务\n```\n[mysqld]\n#master-slave\nserver-id=1\nlog-bin=mysql-bin\nbinlog-do-db=mstest      #要同步的mstest数据库,要同步多个数据库，就多加几个replicate-db-db=数据库名\nbinlog-ignore-db=mysql  #要忽略的数据库\n```\n创建slave账号\n```\nmysql\u003e GRANT REPLICATION SLAVE ON *.* to 'slave_user'@'ipB' identified by 'password';\n#这样就创建了一个用户名为slave_user，密码为password的用户，且只允许该用户的访问来源是localhost或者ipB\n```\n\n完成后，查看master的状态\n![](/blog/images/springMVC-mysql-master-slave/master_status.jpg)\n\n## Slave节点\n\n修改mysql的配置文件my.cnf，增加如下配置，然后重启mysql服务\n```\n[mysqld]\n#master-slave\nserver-id=2\n```\n\n配置master的信息，并且启动slave\n```\nmysql\u003e change master to master_host='ipA',master_user='slave_user',master_password='password',\n         master_log_file='mysql-bin.000015',master_log_pos=424;\n#注意master_log_file和master_log_pos要对应master状态中的File和Position列\n\nmysql\u003e start slave;\n#启动slave\n\n```\n完成后，查看slave的状态，Slave_IO和Slave_SQL的状态必须是yes，否则说明配置失败了\n![](/blog/images/springMVC-mysql-master-slave/slave_status.jpg)\n\n## 测试\n我在A服务器上创建了表test，然后插入两条数据\n![](/blog/images/springMVC-mysql-master-slave/Atables.jpg)\n在B服务器上也能看到\n\n## 注意\n- 最好先在两台服务器上分别手动创建需要同步的数据库，然后再启动slave，否则可能会出问题\n- 上述配置是单向的\n- 直接在slave数据库中进行写操作，会出问题。我尝试直接在ipB上执行insert语句，然后就不再同步了。也就是之后在ipA上的insert不会同步到ipB上。(这部分我还没弄清楚)\n\n\n\n\n\n\n\n","cover":"","link":"springmvc-mysql-master-slave.html","preview":"\u003cp\u003emysql自带主从复制，只要正确配置就可以使用，很简单。\u003c/p\u003e\n","title":"mysql主从复制"},{"content":"\n\n## 常用语法差异\n1. **初始化** \n    - String : String的初始化可以通过`String string = new String(\"a\")` 或 `String string = \"a\"` 实现，它们是有差别的，在这里就不再阐述了\n    - StringBuilder : 只能通过`StringBuilder stringBuilder = new StringBuilder(\"a\")`初始化\n    - StringBuffer :  只能通过`StringBuffer stringBuffer = new StringBuffer(\"a\")`初始化\n\n2. **字符串修改**\n    - String : String是不可变的，从它的定义可见\n\n    ```java\n    public final class String implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence {\n         private final char value[];\n         //......\n    }\n    ```\n    所以它每次修改都是创建了一个新的字符串。他的修改过程: 首先创建一个StringBuffer，然后调用StringBuffer的`append()`方法，最后调用StringBuffer的`toString()`方法返回\n\n    ``` java\n    String s = \"hello\";\n    s += \"world\";\n    //等价于\n    StringBuffer sb = new StringBuffer(\"hello\");\n    sb.append(\"world\");\n    s = sb.toString();\n    ```\n\n    - StringBuilder和StringBuffer : 他们是调用`append()`方法\n\n    ```java\n    //StringBuffer\n    @Override\n    public synchronized StringBuffer append(String str) {\n        toStringCache = null;\n        super.append(str); //它的父类是AbstractStringBuilder\n        return this;\n    }\n\n    //StringBuilder\n    @Override\n    public StringBuilder append(String str) {\n        super.append(str); //它的父类是AbstractStringBuilder\n        return this;\n    }\n    //他们的操作很相似，差异在于StringBuffer做了同步，是线程安全的\n\n    ```\n\n## 效率差异\n我做了一个小实验，分别对String、StringBuffer和StringBuilder修改10000次，查看他们花费的时间。\n``` java\n    public static void main(String[] args) {\n        testString();\n        testStringBuffer();\n        testStringBuilder();\n    }\n    \n    public static void testString() {\n        String a = \"hello\";\n        String b = \"world\";\n        long start = System.currentTimeMillis();\n        for(int i = 0 ; i \u003c 10000 ; i++) {\n            a += b;\n        }\n        long end = System.currentTimeMillis();\n        \n        System.out.println(\"String: \" + (end - start));\n    }\n    \n    public static void testStringBuffer() {\n        StringBuffer a = new StringBuffer(\"hello\");\n        String b = \"world\";\n        long start = System.currentTimeMillis();\n        for(int i = 0 ; i \u003c 10000 ; i++) {\n            a.append(b);\n        }\n        long end = System.currentTimeMillis();\n        \n        System.out.println(\"StringBuffer: \" + (end - start));\n    }\n    \n    public static void testStringBuilder() {\n        StringBuilder a = new StringBuilder(\"hello\");\n        String b = \"world\";\n        long start = System.currentTimeMillis();\n        for(int i = 0 ; i \u003c 10000 ; i++) {\n            a.append(b);\n        }\n        long end = System.currentTimeMillis();\n        \n        System.out.println(\"StringBuilder: \" + (end - start));  \n    }\n```\n\n它的输出结果:\n```out\nString: 236\nStringBuffer: 1\nStringBuilder: 1\n```\n\n不难想到，String每次需要创建新的对象，那么它所花费的时间比如是最多的。顺便说一下，这个实验是在2.2 GHz Intel Core i7、16 GB 1600 MHz DDR3的macOS操作系统上做的。\n\n## 安全差异\n- String是不可变，所以String是线程安全的，因为多个线程同时修改一个String的时候，都是创建了新的字符串\n- StringBuffer是线程安全的，以`append()`方法为例，它在这个方法上面加了同步，而且它用toStringCache来做缓存，避免了同时读写导致的错误，所以它也是安全的\n\n    ```java\n     @Override\n    public synchronized StringBuffer append(String str) {\n        toStringCache = null;\n        super.append(str);\n        return this;\n    }\n\n    @Override\n    public synchronized String toString() {\n        if (toStringCache == null) {\n            toStringCache = Arrays.copyOfRange(value, 0, count);\n        }\n        return new String(toStringCache, true);\n    }\n    ```\n- StringBuilder不是线程安全的，它没有同步也没有缓存\n\n    ```java\n    @Override\n    public StringBuilder append(String str) {\n        super.append(str);\n        return this;\n    }\n    ```\n\n### 总结\n- 效率: StringBuilder \u003e StringBuffer \u003e String\n- 在使用的时候，如果操作的数据量比较小，应该优先使用String\n- 如果是在单线程下大量操作数据，应该优先使用StringBuilder\n- 如果是在多线程下大量操作数据，应该优先使用StringBuffer\n- 乱入: 一个类只能继承一个类，一个类能实现多个接口，一个接口能继承多个接口\n\n\n","cover":"","link":"java-string.html","preview":"\u003cp\u003e在java里面，常用的字符串类包括String、StringBuilder和StringBuffer，之前看过很多这三个类的比较，但是印象一直不深，直到有一次在线上做题，发现相同操作String花费了185ms，而StringBuilder值用了18ms，才意识到它们差别。\u003c/p\u003e\n","title":"java学习笔记 String、StringBuilder、StringBuffer"},{"content":"\n\n\n# Spring MVC 请求参数和返回参数的格式\n\n## 1. 峰驼转下划线\n在JAVA中,变量的命名方式一般为峰驼型(如userName),而在前端则是下划线方式(如user_name),springMVC提供了一种转换的适配\n\n对dispacther的jackson进行配置\n```xml\n\u003cbean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"\u003e\n              \u003cproperty name=\"messageConverters\"\u003e\n                     \u003clist\u003e\n                            \u003cbean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"\u003e\n                                \u003c!-- 驼峰转下划线 --\u003e\n                                \u003cproperty name=\"objectMapper\"\u003e\n                                    \u003cbean class=\"com.fasterxml.jackson.databind.ObjectMapper\"\u003e\n                                        \u003cproperty name=\"propertyNamingStrategy\"\u003e\n                                             \u003cbean class=\"com.fasterxml.jackson.databind.PropertyNamingStrategy.LowerCaseWithUnderscoresStrategy\" /\u003e\n                                        \u003c/property\u003e\n                                     \u003c/bean\u003e\n                                \u003c/property\u003e\n                                \u003cproperty name=\"supportedMediaTypes\"\u003e\n                                    \u003clist\u003e\n                                        \u003c!-- \u003cvalue\u003etext/html;charset=UTF-8\u003c/value\u003e --\u003e\n                                        \u003cvalue\u003eapplication/json; charset=UTF-8\u003c/value\u003e\n                                    \u003c/list\u003e\n                                \u003c/property\u003e\n                                \u003c!-- 驼峰转下划线 --\u003e\n                            \n                            \u003c/bean\u003e\n                            \n                            \u003cbean class=\"org.springframework.http.converter.FormHttpMessageConverter\"/\u003e\n                     \u003c/list\u003e\n              \u003c/property\u003e\n       \u003c/bean\u003e\n```\n\n对于返回的结果，会将后端的userName，转化为前端的user_name\n\n## 2. formdata\n后端接收formdata的时候，可以通过重命名来确定接收的变量在后端的名称，如下，前端传过来的user_name会被放到userName变量\n\n``` java\n@RequestParam(value = \"user_Name\", required = true) String userName\n```\n\n请求数据   `formdata`:  user_name=xxxx\n\n## 3. RequestBody接收json数据\n除了formdata，一般的后台还接收json格式的数据\n\n后端接收参数的方法如下(其中user有私有属性：id,userName,password,name,registerDate)\n\n```java\n@RequestBody User u\n```\n\n\n请求参数\n```json\n{\n    \"id\": 1,\n    \"user_name\": \"dapan\",\n    \"password\": \"123\",\n    \"name\": \"dapan\",\n    \"register_date\": \"1993-10-22\"\n  }\n```\n\n注意的是: 1) 在配置了峰驼转下划线后，请求体中的参数必须满足该规则(也就是user_name =\u003e userName)；2) 参数只能少，不能多，少的置成null，多则出400错误\n\n# Spring MVC AOP 自定义注解\nspringMVC 提供AOP来拦截请求\n\n在本文中，我们通过AOP来检查用户类型；用户类型分：普通用户和管理员\n\n所以我们先定义一个annotation(如下)\n```java\n@Retention(RetentionPolicy.RUNTIME)  \n@Target({ElementType.METHOD,ElementType.TYPE})  \n@Documented  \n//最高优先级  \n@Order(Ordered.HIGHEST_PRECEDENCE)  \npublic @interface CheckUser {\n    UserType type() default UserType.User; //UserType 是一个含有User和Admin的枚举类型\n\n}\n```\n\n然后定义该annotation对应的切片(如下)\n```java\n//before： 函数执行前所需要的操作\n@Before(\"@annotation(com.demo.annotation.CheckUser) \u0026\u0026 (args(request,response,..) || args(..,request,response))\") \n     public void beforeExec(JoinPoint joinPoint,HttpServletRequest request,HttpServletResponse response) {\n         MethodSignature signature = (MethodSignature) joinPoint.getSignature();  \n         Method method = signature.getMethod();  \n         Class\u003c?\u003e classz = joinPoint.getTarget().getClass();\n         \n         CheckUser checkUser = getCheckUser(method,classz);//通过反射，获取注解里面UserType的值\n         \n\n         String token = request.getParameter(\"token\");//获取请求体里面的令牌\n         User user =  SessionManager.getSession(token);//系统中存储\u003c令牌，用户\u003e键值对的管理器\n         if (user != null) {\n             //在这里可以检查用户类型，是否为注解所要求的用户类型\n         } else {\n             //用户令牌无效的情况下，将response截断，并且返回{\"code\":1}(如果不截断，则会根据执行controller后，返回controller定义的类型)\n             try {\n                 response.reset();\n                 response.setStatus(200);\n                 response.setContentType(\"application/json;charset=UTF-8\");\n                 OutputStream out = response.getOutputStream();\n                 out.write(\"{\\\"code\\\":1}\".getBytes());\n                 out.flush();\n                 out.close();\n\n             } catch (Exception e) {\n                 e.printStackTrace();\n             }\n         }\n     }\n```\n\n对应的控制器如下，可以看出当调用getUserList接口的时候，首先会根据自定义的注解CheckUser，去执行相应的aspcet中的(beforeExec)，在aspect中检查用户的权限，根据用户权限来提前截断，或者继续执行\n```java\n    @CheckUser(type=UserType.Admin)\n    @RequestMapping(value=\"getUserList\", method = RequestMethod.GET)\n    @ResponseBody\n    public DataWrapper\u003clist\u003cUser\u003e\u003e getUserList(\n            HttpServletRequest request,\n            HttpServletResponse response,\n            @RequestParam(value = \"token\",required = true) String token\n            ) {\n        \n        return  userService.getUserList(token);\n    }\n```\n\n备注: 根据controller里面@CheckUser可知，在切片中，变量checkUser的值是UserType.Admin\n\n代码在我的git上\n[github](https://github.com/PanruifengWawa/SpringMVC-new)\n\n\n","cover":"","link":"springmvc-aop-underline.html","preview":"\u003col\u003e\n\u003cli\u003espringMVC有很多接收参数的方式，还提供了参数格式转换(峰驼转下划线)。 2. springMVC提供了自定义注解AOP来进行控制反转\u003c/li\u003e\n\u003c/ol\u003e\n","title":"springMVC自定义注解AOP以及请求响应参数格式"},{"content":"\n\n# 赋值\n一般情况下的赋值都是地址引用的传递(引用和指针是有区别的，在java里面没有指针，只有引用，引用是不能被修改的；而指针是可以修改的，如在C++里面有pointer++)\n\n所以在使用JAVA的时候，对于赋值对象的修改需要小心。比如在某些框架下的依赖注入，对于注入的对象，在使用过程中，如果进行修改可能会得到不同的结果。\n\n```JAVA\npublic class Test {\n\t\n\tpublic String name;\n\n\tpublic static void main(String[] args) {\n\t\t//定义变量test，并将其名字定义为dog\n\t\tTest test = new Test();\n\t\ttest.name = \"dog\";\n\t\t\n\t\t//将test赋值给test2，修改其名字为cat\n\t\tTest test2 = test;\n\t\ttest2.name = \"cat\";\n\t\t\n\t\tSystem.out.println(test.name);\n\t\tSystem.out.println(test2.name);\n\t}\n\n}\n```\n\n其输出结果为\n```out\ncat\ncat\n```\n\n可以看出test和test1引用的是内存中的同一个对象，修改任何一个引用，都会影响其他引用。\n\n# 浅拷贝\n浅拷贝是指拷贝对象本身（包括对象中的基本变量），不拷贝对象中的引用。在JAVA中，实现浅拷贝的方法是实现Cloneable接口\n\n举个例子\n```JAVA\npublic class Test implements Cloneable {\n\t\n\tpublic String name;\n\tpublic List\u003cString\u003e values = new ArrayList\u003cString\u003e();\n\t\n\tpublic Test clone() {\n\t\tTest testCloned = null;\n        try {\n        \ttestCloned = (Test) super.clone();\n        } catch (CloneNotSupportedException e) {\n            System.out.println(e.toString());\n        }\n \n        return testCloned;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t//定义变量test\n\t\tTest test = new Test();\n\t\ttest.name = \"dog\";\n\t\ttest.values.add(0, \"dog value\");\n\t\t\n\t\t//将test克隆给test2，并修改test2的内容\n\t\tTest test2 = test.clone();\n\t\ttest2.name = \"cat\";\n\t\ttest2.values.set(0, \"cat value\");\n\t\t\n\t\tSystem.out.println(test.name + \":\" + test.values.get(0));\n\t\tSystem.out.println(test2.name + \":\" + test2.values.get(0));\n\t\t\n\t}\n\t\n}\n```\n\n其结果为\n```out\ndog:cat value\ncat:cat value\n```\n\n可以看出在浅拷贝中，修改基本变量name被拷贝了，所以修改name不会影响其他对象；而List属性则没有被拷贝，所有对象的List属性的值都改变了\n\n# 深拷贝\n## 1. 伪深拷贝\n有一种假的深拷贝，它的方法是对所有涉及到的非基本类型变量都实现Cloneable接口。\n\n比如上面的例子，做法就是重写List对象，让它也实现Cloneable接口，并且修改Test实现的clone的函数。\n```JAVA\ntestCloned = (Test) super.clone();\ntestCloned.values = (List) values.clone();\n```\n为什么说是伪克隆呢？因为如果List对象里面也有非基本类型变量，那么这些非基本变量类型不会被克隆。\n\n比如：假设重写的List里面有对象AClass，用上面的方法，AClass是不会被拷贝的。\n\n这种伪深拷贝的关键是`覆盖拷贝`。\n\n![](/blog/images/copy/copy.png)\n\n## 2. 深拷贝\n序列化(串行化)是深拷贝的一个方法。\n\n过程：内存对象 -\u003e 序列化 -\u003e 新的内存对象。 这样前后两个对象的内容是一致的，但是在内存中的引用不一样。\n\n序列化的过程如下：\n\n```JAVA\npublic static \u003cT extends Serializable\u003e T clone(T obj) {\n\tT clonedObj = null;\n\ttry {\n\t\t//将对象变成序列（序列号）\n\t\tByteArrayOutputStream output = new ByteArrayOutputStream();\n\t\tObjectOutputStream objOutput = new ObjectOutputStream(output);\n\t\tobjOutput.writeObject(obj);\n\t\tobjOutput.close();\n\t\t\n\t\t//将序列还原成对象（反序列化）\n\t\tByteArrayInputStream input = new ByteArrayInputStream(output.toByteArray());\n\t\tObjectInputStream objInput = new ObjectInputStream(input);\n\t\t\t\n\t\tclonedObj = (T) objInput.readObject();\n\t\t\n\t\tobjInput.close();\n\t} catch (IOException | ClassNotFoundException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\n\t\t\n\treturn clonedObj;\n\t\t\n}\n```\n\n在使用这个clone函数的时候，需要让原有对象实现Serializable接口(从clone函数的参数也能看出)。\n\n```JAVA\npublic class Test implements Serializable {\n\n\tprivate static final long serialVersionUID = -2386382139170837795L;\n\tpublic String name;\n\tpublic List\u003cString\u003e values = new ArrayList\u003cString\u003e();\n\n\tpublic static void main(String[] args) {\n\t\t//定义变量test\n\t\tTest test = new Test();\n\t\ttest.name = \"dog\";\n\t\ttest.values.add(0, \"dog value\");\n\t\t\n\t\t//将test克隆给test2\n\t\tTest test2 = clone(test);\n\t\ttest2.name = \"cat\";\n\t\ttest2.values.set(0, \"cat value\");\n\t\t\n\t\tSystem.out.println(test.name + \":\" + test.values.get(0));\n\t\tSystem.out.println(test2.name + \":\" + test2.values.get(0));\n\t\t\n\t}\n\t\n}\n```\n结果为:\n```out\ndog:dog value\ncat:cat value\n```\n\n\n\n\n\n\n\n","cover":"","link":"copy.html","preview":"\u003cp\u003eJAVA里面变量有两种拷贝的方法，深拷贝和浅拷贝。\u003c/p\u003e\n","title":"JAVA深拷贝和浅拷贝"},{"content":"\n\n## 题目\n最近学长们在各种投简历，他们在线笔试的时候正好看到一道很有趣的在线笔试题，就自己做了一下，由于没有答案，所以也不知道对不对。\n\n- 1. 对于一个长度为N的整形数组A，数组里所有的数都是正整数，对于两个满足`0\u003c=X\u003c=Y\u003cN`的整数，A[X],A[X+1]...A[Y]构成A的一个切片，记作`(X,Y)`。\n- 2. 用三个下标m1,m2,m3满足条件 `0\u003cm1`, `m1+1\u003cm2`, `m2+1\u003cm3\u003cN-1`。\n- 3. 可以把这个整数分成 `(0,m1-1)`, `(m1+1,m2-1)`, `(m2+1,m3-1)`, `(m3+1,N-1)` 四个切片。如果这四个切片中的整数求和相等，称作“四等分”。\n- 4. 编写一个函数，判断是否可以四等分，如果可以，返回true，否则返回false。\n- 5. 限制条件: N \u003c= 1000000，整数范围取值介于 0 到 1000000之间。\n- 6. 要求: 时间复杂度O(N)，额外的存储空间最多为O(N);\n- 7. 对于数组 A=[2,5,1,1,1,1,4,1,7,3,7]，存在下标2，7，9使得A分成四个切片 [2,5] , [1,1,1,4], [7], [7] 这四个切片求和相等。 对于数组 A=[10,2,11,13,1,1,1,1,1]找不到四等分，所以返回false。\n\n## 方法\n首先，由于约束条件`0\u003cm1`, `m1+1\u003cm2`, `m2+1\u003cm3\u003cN-1`，可知最小值 m1=1, m2=3, m3=5, N\u003e6， 所以对于数组长度小于等于6的返回false。\n\n\u003col\u003e\n\t\u003cli\u003e任取满足条件的m1,m2,m3构成四个切片，并且求四个切片的和 sum1, sum2, sum3, sum4\u003c/li\u003e\n\t\u003cimg src=\"images/interview-questions/1.png\"\u003e\n\t\u003cli\u003e如果 \u003cspan style=\"color:red;\"\u003esum1=sum2=sum3=sum4\u003c/span\u003e ,那么说明可以是一个四等分的切片，且 \u003cspan style=\"color:red;\"\u003em1,m2,m3\u003c/span\u003e 就是结果，跳出迭代\u003c/li\u003e\n\t\u003cli\u003e如果某次迭代不满足这个条件，我的想法是 \u003cspan style=\"color:red;\"\u003e消灭最大的sum\u003c/span\u003e，也就是将\u003cspan style=\"color:red;\"\u003e和最大\u003c/span\u003e的切片的边缘分配给相邻较小的切片。(切片是相邻的，所以只能分配给相邻的另一个切片)\n\t\t\u003cul\u003e\n\t\t\t\u003cli\u003e当sum1最大的时候，将m1往左边移1位(\u003cspan style=\"color:red;\"\u003em1=m1-1\u003c/span\u003e)，此时 \u003cspan style=\"color:red;\"\u003esum1 = sum1 - A[m1-1]\u003c/span\u003e,而 \u003cspan style=\"color:red;\"\u003esum2 = sum2 + A[m1]\u003c/span\u003e。\u003c/li\u003e\n\t\t\t\u003cli\u003e当sum2最大的时候，切片2的边缘分配给相邻较小的切片。也就是说，当 \u003cspan style=\"color:red;\"\u003esum1 \u003e sum3\u003c/span\u003e 的时候，分配给sum3,此时 \u003cspan style=\"color:red;\"\u003em2=m2-1\u003c/span\u003e, \u003cspan style=\"color:red;\"\u003esum2 = sum2 - A[m2-1]\u003c/span\u003e,\u003cspan style=\"color:red;\"\u003e sum3 = sum3 + A[m2]\u003c/span\u003e;同理当 \u003cspan style=\"color:red;\"\u003esum1 \u003c= sum3\u003c/span\u003e 的时候，分配给sum1,方法如上\u003c/li\u003e\n\t\t\t\u003cli\u003e当sum3最大的时候，这种情况和sum2最大类似(都是数组的内部切片)\u003c/li\u003e\n\t\t\t\u003cli\u003e当sum4最大的时候，这种情况和sum1最大类似(都是数组的外部切片)\u003c/li\u003e\n\t\t\u003c/ul\u003e\n\t\u003c/li\u003e\n\t\u003cli\u003e重复步骤2，3\u003c/li\u003e\n\t\u003cli\u003e失败跳出的条件：最大切片的位置变化进入循环。如\u003cspan style=\"color:red;\"\u003e1 -\u003e 2 -\u003e 1\u003c/span\u003e, 其意义是：当切片1和最大的时候，分配边缘给切片2；当切片2和最大的时候，又将边缘还给了切片1，如此进入死循环。\u003c/li\u003e\n\u003c/ol\u003e\n\n## 分析\n### 空间复杂度\n除了几个可数的变量以外，没有使用额外的空间，所以空间复杂度为 O(N)\n\n### 时间复杂度\n求sum1-sum4的时候，需要遍历一遍数组，时间花费N\n\n步骤3，其实是在调整m1,m2,m3的位置，它的位置变化最多为N，因为 0\u003cm1\u003cm2\u003cm3\u003cN，而m1,m2,m3只会往一个方向变化，否则就会进入失败的条件。所以时间复杂度为 O(N)\n\n## 注意\n这个方法不一定对，只是我的一个想法\n\n## 代码\n``` java\npackage main;\n\n\npublic class Main {\n\n\tpublic static boolean handle(int[] A) {\n\t\tboolean flag = false;\n\n\t\tint m1 = 1, m2 = 3, m3 = 5; \n\t\t//用数组存比较好，这里为了清楚展示就没用数组\n\n\t\tlong sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0; \n\t\t//用数组存比较好，这里为了清楚展示就没用数组\n\n\t\tint latestMax1 = -3, latestMax2 = -2, thisMax = -1; \n\t\t//用数组存比较好，这里为了清楚展示就没用数组\n\t\t//latestMax1 上上次取的最大值所在的位置\n\t\t//latestMax2 上次取的最大值所在的位置\n\t\t//thisMax 当前的最大值所在的位置\n\t\t\n\t\tif (A.length \u003c= 6) {\n\t\t\treturn flag;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i \u003c A.length; i++) {\n\t\t\tif (i \u003e= 0 \u0026\u0026 i \u003c m1) { //求sum1\n\t\t\t\tsum1 += A[i];\n\t\t\t}\n\t\t\tif (i \u003e m1 \u0026\u0026 i\u003c m2) { //求sum2\n\t\t\t\tsum2 += A[i];\n\t\t\t}\n\t\t\tif (i \u003e m2 \u0026\u0026 i \u003c m3) { //求sum3\n\t\t\t\tsum3 += A[i];\n\t\t\t}\n\t\t\tif (i \u003e m3) { //求sum4\n\t\t\t\tsum4 += A[i];\n\t\t\t}\n\t\t}\n\t\t//以上时间花费 N\n\t\t\n\t\t\n\t\twhile(true) {\n\t\t\tif (sum1 == sum2 \u0026\u0026 sum1 == sum3 \u0026\u0026 sum1 == sum4) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (latestMax1 !=latestMax2 \u0026\u0026 latestMax1 == thisMax) {\n\t\t\t\t//判断失败\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tlatestMax1 = latestMax2;\n\t\t\tlatestMax2 = thisMax;\n\t\t\t\n\t\t\tif (sum1 \u003e= sum2 \u0026\u0026 sum1 \u003e= sum3 \u0026\u0026 sum1 \u003e= sum4) { \n\t\t\t\t//sum1 最大\n\t\t\t\tsum1 -= A[m1-1];\n\t\t\t\tsum2 += A[m1];\n\t\t\t\tm1 -= 1; // m1 往左移1位\n\t\t\t\tthisMax = 1;\n\t\t\t} else if (sum2 \u003e= sum1 \u0026\u0026 sum2 \u003e= sum3 \u0026\u0026 sum2 \u003e= sum4) { \n\t\t\t\t//sum2 最大\n\t\t\t\tif (sum1 \u003e sum3) { //sum1比sum3大的情况\n\t\t\t\t\tsum2 -= A[m2-1];\n\t\t\t\t\tsum3 += A[m2];\n\t\t\t\t\tm2 -= 1;\n\t\t\t\t} else {\n\t\t\t\t\tsum1 += A[m1];\n\t\t\t\t\tsum2 -= A[m1+1];\n\t\t\t\t\tm1 += 1;\n\t\t\t\t}\n\t\t\t\tthisMax = 2;\n\t\t\t} else if (sum3 \u003e= sum1 \u0026\u0026 sum3 \u003e= sum2 \u0026\u0026 sum3 \u003e= sum4) { \n\t\t\t\t//sum3 最大\n\t\t\t\tif (sum2 \u003e sum4) { //sum2比sum4大的情况\n\t\t\t\t\tsum4 += A[m3];\n\t\t\t\t\tsum3 -= A[m3-1];\n\t\t\t\t\tm3 -= 1;\n\t\t\t\t} else {\n\t\t\t\t\tsum2 += A[m2];\n\t\t\t\t\tsum3 -= A[m2+1];\n\t\t\t\t\tm2 += 1;\n\t\t\t\t}\n\t\t\t\tthisMax = 3;\n\t\t\t} else if (sum4 \u003e= sum1 \u0026\u0026 sum4 \u003e= sum2 \u0026\u0026 sum4 \u003e= sum3) { \n\t\t\t\t//sum4 最大\n\t\t\t\tsum4 -= A[m3+1];\n\t\t\t\tsum3 += A[m3];\n\t\t\t\tm3 += 1;\n\t\t\t\tthisMax = 4;\n\t\t\t} \n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.print(flag);\n\t\tif (flag) {\n\t\t\tSystem.out.println(\",m1=\" + m1 + \",m2=\" + m2 + \",m3=\" + m3);\n\t\t}\n\t\t\n\n\t\treturn flag;\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\tint A[] = {2,5,1,1,1,1,4,1,7,3,7};\n\t\tint B[] = {10,2,11,13,1,1,1,1,1};\n\t\thandle(A);\n\t\thandle(B);\n\t}\n\n}\n\n```\n\n输出：\n``` sysout\ntrue,m1=2,m2=7,m3=9\nfalse\n```\n\n如我在代码中的注释，用数组去存定义的变量更好，以position去进行if判断，可以减少重复代码，但是我想让代码容易被看懂，所以没用数组，而是枚举if\n\n","cover":"","link":"interview-questions.html","preview":"\u003cp\u003e最近学长们在各种投简历，他们在线笔试的时候正好看到一道很有趣的在线笔试题，就自己做了一下，由于没有答案，所以也不知道对不对。\u003c/p\u003e\n","title":"某里JAVA实习在线笔试题"},{"content":"\n\n## date，timestamp和datetime\n首先，介绍一下mysql中，常用的时间字段，有date、timestamp和datetime。\n\n- `date` 大小：3 bytes，格式：'YYYY-MM-DD'，范围：'1000-01-01 ~ 9999-12-31'\n- `timestamp` 大小：4 bytes，格式：'YYYY-MM-DD HH:MM:SS'，范围：'1970-01-01 08:00:01 ~ 2038-01-19 11:14:07'\n- `datetime` 大小：8 bytes，格式：'YYYY-MM-DD HH:MM:SS'，范围：'1000-01-01 00:00:00 ~ 9999-12-31 23:59:59'\n\n在需要精确到时秒分的情况下，我们通常会选择timestamp或者datetime。当时我看别人写的都是用timestamp，而自己又没有去查mysql的文档，所以用的时间戳都是timestamp。\n\n## 问题描述\n首先，我们创建一张有timestamp类型的表，用于记录名字和注册时间\n``` mysql\ncreate table test1 (\nid serial primary key,\nname varchar(30) not null,\nregister_time timestamp not null\n);\n```\n然后插入一条数据\n``` myysql\ninsert into test1(name,register_time) values('dog',now());\n```\n![](/blog/images/mysql-timestamp/selectdata.png)\n到目前为止，还没有出现任何问题\n\n有一天，dog用户表示自己改名字了，他觉得自己应该叫'chick'，然后他就改名字了\n``` mysql\nupdate test1 set name = 'chick' where id = 1;\n```\n![](/blog/images/mysql-timestamp/selectdata2.png)\n好像也没什么问题。等等！注册时间怎么变了？dog表示不服，因为老用户有很多福利，而自己不过是修改了一下名字，怎么注册时间更新了？\n\n## timestamp\ntimestamp所占存储空间比较小，但是它有一个特性：默认情况下，在`insert, update`数据时，timestamp 列会自动以当前时间`填充/更新`。\n\n基于这个特性，timestamp适用类似于`updated_time`的字段，而且它所占的存储空间也比较小；不过需要注意的是timestamp比较受时区timezone的影响。\n\n当然也可以取消timestamp在`update`下的自动更新时间\n``` mysql\ncreate table test2 (\nid serial primary key,\nname varchar(30) not null,\nregister_time timestamp not null default current_timestamp\n);\n```\n这种情况下，当执行`update`的时候，不会去自动更新时间\n\n## datetime\n它只是个普通的时间字段，不会自动以当前时间`填充/更新`，注意的是datetime在非空的情况下也会自动填充。\n``` mysql \ncreate table test3 (\nid serial primary key,\nname varchar(30) not null,\nregister_time datetime not null\n);\ninsert into test3(name) values('dog');\n```\n上述情况不会报错，而是会给出一个warning，而且datetime字段会自动填充。\n![](/blog/images/mysql-timestamp/selectdata3.png)\n\n当然如果是可为空的情况下，那么register_time的值就是NULL。\n\n由于datetime比较大，选择datetime作为索引，可能会遇到大量数据查询慢的情况，不过可以使用分区表解决。","cover":"","link":"mysql-timestamp.html","preview":"\u003cp\u003e在实习的时候，看到mysql建表，对于时间字段用的都是timestamp类型。之后在自己的项目中，不问缘由，也全部使用timestamp，然后发生了一系列问题。\u003c/p\u003e\n","title":"mysql timestamp和datetime"},{"content":"\n\n## web页面乱码\n如果是html页面，可以使用\n``` html\n\u003cmeta http-equiv=\"content-type\" content=\"text/html;charset=gbk\" /\u003e\n```\n如果是jsp页面，可以使用\n``` html\n\u003c%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%\u003e  \n```\n\n## 后端服务器中中文乱码\n当服务器接收到网页请求参数，参数是中文，而且发生乱码，则可能是由于一下原因：\n\n- web页面中文编码和后端服务器编码不一致，比如说web客户端使用的是ISO的编码，而服务器使用的是其他编码，就会出现乱码\n- 客户端使用了URLEncode\n\n可能的解决方案：\n\n- 对于第一种原因，需要对接收的每个字符串变量重新编码或者对请求增加filter\n\n\u0026emsp;\u0026emsp;\u0026emsp;1. 重新编码比较简单\n\n``` java\nnew String(request.getParameter(\"str\").getBytes(\"ISO-8859-1\"),\"UTF-8\")\n```\n\n\u0026emsp;\u0026emsp;\u0026emsp;2. 增加filter\n\n\u0026emsp;\u0026emsp;\u0026emsp;修改项目配置文件`web.xml`，增加如下代码\n``` xml\n\u003cfilter\u003e  \n    \u003cfilter-name\u003echaracterEncodingFilter\u003c/filter-name\u003e  \n    \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e  \n    \u003cinit-param\u003e  \n    \t\u003cparam-name\u003eencoding\u003c/param-name\u003e  \n    \t\u003cparam-value\u003eUTF-8\u003c/param-value\u003e  \n    \u003c/init-param\u003e  \n    \u003cinit-param\u003e  \n            \u003cparam-name\u003eforceEncoding\u003c/param-name\u003e  \n            \u003cparam-value\u003etrue\u003c/param-value\u003e  \n    \u003c/init-param\u003e  \n\u003c/filter\u003e  \n\u003cfilter-mapping\u003e  \n    \u003cfilter-name\u003echaracterEncodingFilter\u003c/filter-name\u003e  \n    \u003curl-pattern\u003e/*\u003c/url-pattern\u003e  \n\u003c/filter-mapping\u003e  \n```\n\u003cbr/\u003e\n\n- 对于第二种原因，一般是不会发生乱码的，发生乱码一般是由于请求为`GET`请求，中文参数放在URL内，而服务器没有进行相应的设置\n\n\u0026emsp;\u0026emsp;\u0026emsp;以tomcat为例，修改`server.xml`，增加`URIEncoding=\"UTF-8\"`即可\n``` xml\n\u003cConnector URIEncoding=\"UTF-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/\u003e\n```\n\n## 数据库乱码（mysql）\n如果服务没有出现乱码，那么说明是数据库的语言配置出问题了，可以通过`show variables like 'character_set_%';`来查看数据库的编码\n![](/blog/images/springMVC-mysql-gibberish/mysql-charset.jpeg)\n\n其中需要关注的是`服务器`、`数据库`和`数据表部分`的编码，如果这三部分不是你想要的编码，那么需要修改。\n``` sql\nmysql\u003e SET character_set_client='utf8';\nmysql\u003e SET character_set_connection='utf8';\nmysql\u003e SET character_set_results='utf8';\n```\n\n\u003e 注意的是，上述的仅作用于当前的session，也就是当前数据库用户退出后失效\n\n如果想永久设置，需要修改mysql的`my.cnf`，通过`vim /etc/my.cnf`命令来编辑该文件，进入编辑状态后，在其中修改\n``` cnf\n[mysqld]\ndefault-character-set=utf8\n\n[client]\ndefault-character-set=utf8\n\n[mysql]\ndefault-character-set=utf8\n```\n修改完成后，重启数据库即可，`service mysqld restart`\n\n除了上述修改编码的方式，还可以在建表时指定表的charset。有的时候一个数据库可能有多个用户在使用，如果直接修改整个数据库的编码，可能造成其他用户的不便，所以可以不改变整个系统的语言，仅指定自己所建表的编码\n``` sql\ncreate table mytable(\n\tname varchar(100)\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\n\n\n","cover":"","link":"springmvc-mysql-gibberish.html","preview":"\u003cp\u003e在使用springMVC + Hibernate时，有时会出现中文乱码。一般中文乱码出现在web页面，后端服务器和数据库中，而其原因有很多。\u003c/p\u003e\n","title":"springMVC-mysql中文乱码"},{"content":"\n\n## github个人主页(github pages)简介\n\ngithub pages简介以及如何搭建在[github help](https://help.github.com/categories/github-pages-basics/)里有详细的描述。\n本文目的是将其步骤简化，达到快速搭建github个人主页的目的。\n\n### 搭建步骤\n1. 申请一个github账号\n2. 登录后，新建一个代码仓库，仓库名为 yourusername.github.io\n\n    ![新建代码仓库过程](/blog/images/github-personal-website/create_new_repository.jpeg)\n\n    \u003e 图片中的warning是由于本人已经创建过该仓库了\n\n3. 在本地电脑安装[github工具](https://git-for-windows.github.io/)，这里给出的是windows版本的，linux和mac的自行安装\n4. 在本地新建一个文件夹，进入文件夹后新建一个`index.html`的文件，用记事本打开它，在里面写入`我的个人主页`(如果你会html，那么可以在里面编辑自己想要的页面)\n5. 将该文件夹里面的文件`index.html`推到新建的代码仓库，github本地配置以及将代码推到远程仓库的教程已经有很多了，这里可以参照[这一篇](http://blog.csdn.net/qq_24489717/article/details/52556072)\n6. 上传代码完成后，可通过`yourusername.github.io`这个域名访问你的个人主页了\n","cover":"","link":"github-personal-website.html","preview":"\u003cp\u003egithub除了提供分布式代码管理，还提供了个人主页的搭建。\u003c/p\u003e\n","title":"github个人主页搭建"}]